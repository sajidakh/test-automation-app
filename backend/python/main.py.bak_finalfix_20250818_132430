from __future__ import annotations

import json
import os
import sys
import uuid
from typing import List

from fastapi import Depends, FastAPI, Header, HTTPException, Request
from fastapi.responses import JSONResponse, PlainTextResponse
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware import Middleware

from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
from slowapi.util import get_remote_address


# ---------- CORS CONFIG ----------
def _normalize(origins: object) -> List[str]:
    if isinstance(origins, str):
        return [s.strip() for s in origins.split(",") if s.strip()]
    if isinstance(origins, (list, tuple, set)):
        return [str(x).strip() for x in origins if str(x).strip()]
    return []

_env = (os.getenv("PF_ENV") or "dev").lower()
_raw_allow = os.getenv("PF_CORS_ORIGINS")

# If the env var is present at all, we go STRICT (no wildcard).
if _raw_allow is not None:
    _allow_list: List[str] = _normalize(_raw_allow)
    _allow_any = False
else:
    _allow_list = []
    _allow_any = (_env != "prod")  # dev convenience only when nothing configured

cors_kwargs = dict(
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["x-request-id"],
)

if _allow_any:
    # Dev only: permissive. (Note: Starlette will echo Origin when credentials=True.)
    cors_kwargs.update(allow_origins=["*"])
else:
    # Strict: only configured list; explicitly disable any regex fallback.
    cors_kwargs.update(allow_origins=_allow_list, allow_origin_regex=None)

cors_mw = Middleware(CORSMiddleware, **cors_kwargs)

# ---------- App (middleware wired at construction) ----------
app = FastAPI(title="Project Forge API", middleware=[cors_mw])

# ---------- Request ID + JSON logs ----------
@app.middleware("http")
async def _request_meta(request: Request, call_next):
    rid = request.headers.get("x-request-id") or str(uuid.uuid4())
    request.state.request_id = rid
    try:
        print(json.dumps({
            "level": "INFO", "logger": "api", "message": "request_start",
            "time": "", "request_id": rid, "path": request.url.path, "method": request.method,
        }), file=sys.stderr, flush=True)
    except Exception:
        pass

    response = await call_next(request)
    response.headers["x-request-id"] = rid

    try:
        print(json.dumps({
            "level": "INFO", "logger": "api", "message": "request_end",
            "time": "", "request_id": rid, "path": request.url.path, "status": response.status_code,
        }), file=sys.stderr, flush=True)
    except Exception:
        pass

    return response

# ---------- Global error envelope (must include ok:false and error.code) ----------
@app.exception_handler(Exception)
async def _unhandled(request: Request, exc: Exception):
    rid = getattr(getattr(request, "state", None), "request_id", None)
    return JSONResponse(
        status_code=500,
        content={
            "ok": False,
            "error": {"type": "InternalServerError", "code": "internal_error", "message": "internal error"},
            "request_id": rid,
        },
    )

# ---------- Rate limiting ----------
_rate_per_minute = os.getenv("PF_RATE_PER_MINUTE") or "60"
limiter = Limiter(key_func=get_remote_address, default_limits=[f"{_rate_per_minute}/minute"])
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ---------- API key guard ----------
def require_api_key(x_api_key: str | None = Header(default=None)) -> None:
    expected = os.getenv("PF_API_KEY")
    if not x_api_key:
        raise HTTPException(status_code=401, detail="missing api key")
    if expected is not None and x_api_key != expected:
        raise HTTPException(status_code=401, detail="invalid api key")

# ---------- Endpoints ----------
@limiter.limit(lambda: os.getenv("PF_RATE_PER_MINUTE") or "60")
@app.get("/health")
async def health(request: Request):
    return PlainTextResponse("ok")

@app.get("/secure-ping", dependencies=[Depends(require_api_key)])
async def secure_ping(request: Request):
    return {"pong": True}

@app.get("/projects", dependencies=[Depends(require_api_key)])
async def projects(request: Request):
    items: List[dict] = []
    return {"items": items, "count": len(items)}