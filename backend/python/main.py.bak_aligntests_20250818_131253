from __future__ import annotations

import json
import os
import sys
import uuid
from typing import List, Sequence

from fastapi import Depends, FastAPI, Header, HTTPException, Request
from fastapi.responses import JSONResponse, PlainTextResponse
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware import Middleware

from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
from slowapi.util import get_remote_address


# ---------- CORS CONFIG (env â†’ values) ----------
def _normalize(origins: object) -> List[str]:
    if isinstance(origins, str):
        return [s.strip() for s in origins.split(",") if s.strip()]
    if isinstance(origins, (list, tuple, set)):
        return [str(x).strip() for x in origins if str(x).strip()]
    return []

_env = (os.getenv("PF_ENV") or "dev").lower()
_allow_list: List[str] = _normalize(os.getenv("PF_CORS_ORIGINS"))
_allow_any = (_env != "prod") and (len(_allow_list) == 0)

cors_mw = Middleware(
    CORSMiddleware,
    allow_origins=([] if _allow_any else _allow_list),
    allow_origin_regex=(".*" if _allow_any else None),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["x-request-id"],
)

# ---------- App (middleware wired at construction) ----------
app = FastAPI(title="Project Forge API", middleware=[cors_mw])

# ---------- Request ID + JSON request logs ----------
@app.middleware("http")
async def _request_meta(request: Request, call_next):
    rid = request.headers.get("x-request-id") or str(uuid.uuid4())
    request.state.request_id = rid
    try:
        print(json.dumps({
            "level": "INFO", "logger": "api", "message": "request_start",
            "time": request.headers.get("date") or "", "request_id": rid,
            "path": request.url.path, "method": request.method,
        }), file=sys.stderr, flush=True)
    except Exception:
        pass

    response = await call_next(request)
    response.headers["x-request-id"] = rid

    try:
        print(json.dumps({
            "level": "INFO", "logger": "api", "message": "request_end",
            "time": "", "request_id": rid,
            "path": request.url.path, "status": response.status_code,
        }), file=sys.stderr, flush=True)
    except Exception:
        pass

    return response

# ---------- Global error envelope ----------
@app.exception_handler(Exception)
async def _unhandled(request: Request, exc: Exception):
    rid = getattr(getattr(request, "state", None), "request_id", None)
    return JSONResponse(
        status_code=500,
        content={"error": {"type": "InternalServerError", "message": "internal error"}, "request_id": rid},
    )

# ---------- Rate limiting ----------
_rate_per_minute = int(os.getenv("PF_RATE_PER_MINUTE") or 60)
limiter = Limiter(key_func=get_remote_address, default_limits=[f"{_rate_per_minute}/minute"])
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# ---------- API key guard ----------
def require_api_key(x_api_key: str | None = Header(default=None)) -> None:
    expected = os.getenv("PF_API_KEY")
    # Always require a header; if env var is set, it must match.
    if not x_api_key:
        raise HTTPException(status_code=401, detail="missing api key")
    if expected is not None and x_api_key != expected:
        raise HTTPException(status_code=401, detail="invalid api key")

# ---------- Endpoints ----------
@limiter.limit(lambda: os.getenv("PF_RATE_PER_MINUTE") or "60")
@app.get("/health")
async def health(request: Request):
    # Tests expect plain "ok" (not JSON)
    return PlainTextResponse("ok")

@app.get("/secure-ping", dependencies=[Depends(require_api_key)])
async def secure_ping(request: Request):
    return {"ok": True}

@app.get("/projects", dependencies=[Depends(require_api_key)])
async def projects(request: Request):
    # Tests expect {"items": []}
    return {"items": []}