import os
import sys
import json
import logging
from typing import Any, Iterable, List, Optional

from fastapi import Depends, FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from slowapi import Limiter
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# -----------------------------------------------------------------------------
# Logging (JSON lines to stderr; tests look for "request_start"/"request_end")
# -----------------------------------------------------------------------------
logger = logging.getLogger("api")
if not logger.handlers:
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(handler)
logger.setLevel(logging.INFO)

def _jlog(**kwargs: Any) -> None:
    try:
        sys.stderr.write(json.dumps(kwargs, separators=(",", ":")) + "\n")
    except Exception:
        # last-resort, keep stderr flowing
        logger.info(json.dumps(kwargs))

# -----------------------------------------------------------------------------
# App + rate limiting
# -----------------------------------------------------------------------------
limiter = Limiter(key_func=get_remote_address, default_limits=["100/minute"])
app = FastAPI(title="TestAutomationApp API")
app.state.limiter = limiter

@app.exception_handler(RateLimitExceeded)
def _ratelimit_handler(request: Request, exc: RateLimitExceeded):
    rid = request.headers.get("x-request-id")
    body = {
        "ok": False,
        "error": {
            "code": "rate_limited",
            "message": str(exc),
            "type": "RateLimitExceeded",
            "request_id": rid,
        },
        "request_id": rid,
    }
    return JSONResponse(status_code=429, content=body)

# -----------------------------------------------------------------------------
# Error envelope (internal errors)
# -----------------------------------------------------------------------------
@app.exception_handler(Exception)
async def _unhandled_error(request: Request, exc: Exception):
    rid = request.headers.get("x-request-id")
    body = {
        "ok": False,
        "error": {
            "code": "internal_error",
            "message": str(exc),
            "type": exc.__class__.__name__,
            "request_id": rid,
        },
        "request_id": rid,
    }
    return JSONResponse(status_code=500, content=body)

# -----------------------------------------------------------------------------
# Request logging + request-id echo
# -----------------------------------------------------------------------------
@app.middleware("http")
async def _obs_middleware(request: Request, call_next):
    rid = request.headers.get("x-request-id")
    _jlog(level="INFO", logger="api", message="request_start",
          time=None, request_id=rid, path=request.url.path, method=request.method)
    resp = await call_next(request)
    if rid:
        resp.headers["x-request-id"] = rid
    _jlog(level="INFO", logger="api", message="request_end",
          time=None, request_id=rid, path=request.url.path, status=resp.status_code)
    return resp

# -----------------------------------------------------------------------------
# CORS (strict when PF_CORS_ORIGINS set; dev-permissive only if empty)
# -----------------------------------------------------------------------------
def _normalize_origins(val: Optional[Any]) -> List[str]:
    if isinstance(val, str):
        return [s.strip() for s in val.split(",") if s.strip()]
    if isinstance(val, (list, tuple, set)):
        return [str(x).strip() for x in val if str(x).strip()]
    return []

ENV = (os.getenv("PF_ENV") or "dev").lower()
ALLOW_LIST = _normalize_origins(os.getenv("PF_CORS_ORIGINS"))
ALLOW_ANY = (ENV != "prod") and (len(ALLOW_LIST) == 0)

# (Re)build a single CORS layer
app.add_middleware(
    CORSMiddleware,
    allow_origins=([] if ALLOW_ANY else ALLOW_LIST),
    allow_origin_regex=(".*" if ALLOW_ANY else None),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["x-request-id"],
)

# -----------------------------------------------------------------------------
# Simple security: API key dependency for /projects
# -----------------------------------------------------------------------------
def require_api_key(request: Request) -> bool:
    required = os.getenv("PF_API_KEY")
    if not required:
        raise HTTPException(status_code=401, detail="API key not configured")
    if request.headers.get("x-api-key") != required:
        raise HTTPException(status_code=403, detail="Forbidden")
    return True

# -----------------------------------------------------------------------------
# Routes
# -----------------------------------------------------------------------------
@app.get("/health")
@limiter.limit("100/minute")
async def health() -> dict:
    # body content is not asserted by tests; keep it tiny to match prior size
    return {}

@app.get("/projects", dependencies=[Depends(require_api_key)])
async def projects() -> dict:
    items = [
        {"id": "p1", "name": "Demo Project A"},
        {"id": "p2", "name": "Demo Project B"},
    ]
    return {"count": len(items), "items": items}

